import Button from '@mui/material/Button';
import Stack from '@mui/material/Stack';
import ListItems from '../../components/ListItems';
import Divider from '@mui/material/Divider';
import { Outlet, useNavigate, useSearchParams } from 'react-router-dom';
import {
  createContext,
  useCallback,
  useEffect,
  useState,
} from 'react';
import { useQuery } from 'react-query';
import { myApi } from '../../tools/apiHandler';
import { deserializeMessage, Message, Room, Serialized } from './types';
import ContextMenu from '../../components/ContextMenu';
import {
  Dialog,
  DialogActions,
  DialogContent,
  DialogTitle,
  useTheme,
} from '@mui/material';
import {
  GetRoomResponseDTO,
} from '../../tools/api.autogenerated';
import { useChatSocket } from '../../layouts/MainLayout';

const sortRoomFunc = (a: Room, b: Room) => {
  return b.unreadMessages - a.unreadMessages;
};

export interface IChatContext {
  rooms: Room[];
  setRooms: React.Dispatch<React.SetStateAction<Room[]>>;
  updateRoom: (
    roomId: string,
    newVal: Partial<Room> | ((curr: Room) => Partial<Room>),
  ) => void;
  roomId: string | null;
  onBanned: (by: string) => void;
  roomData: GetRoomResponseDTO | null;
  refetchRoomData: () => void;
}

const defaultChatContext: IChatContext = {
  rooms: [],
  setRooms: () => {},
  updateRoom: () => {},
  roomId: null,
  onBanned: () => {},
  roomData: null,
  refetchRoomData: () => {},
};

type BannedDialogData = {
  open: boolean;
  by: string;
  roomName: string;
};

export const chatContext = createContext<IChatContext>(
  null as unknown as IChatContext,
);

function Layout() {
  const navigate = useNavigate();
  const socket = useChatSocket().socket;
  const [rooms, setRooms] = useState<Room[]>([]);
  const [searchParams, setSearchParams] = useSearchParams();
  const [selectedRoomId, setSelectedRoomId] = useState<string | null>(null);
  const [bannedDialogData, setBannedDialogData] = useState<BannedDialogData>({
    by: '',
    roomName: '',
    open: false,
  });
  const { isLoading, data, refetch } = useQuery(
    'rooms',
    () => myApi.chatControllerGetRooms(),
    {
      refetchOnWindowFocus: false,
      refetchOnReconnect: false,
      cacheTime: 0,
    },
  );

  const roomQuery = useQuery(
    'messages',
    () => myApi.chatControllerGetRoom(selectedRoomId!),
    {
      enabled: selectedRoomId !== null, // <== triggered when this condition is true
      refetchOnWindowFocus: true,
      refetchOnReconnect: false,
      refetchInterval: 5000,
      cacheTime: 0,
    },
  );

  // Helper function to update a single room inside the rooms array
  const updateRoom = (
    roomId: string,
    newVal: Partial<Room> | ((curr: Room) => Partial<Room>),
  ) => {
    setRooms((currentArray) =>
      currentArray.map((room) =>
        room.id === roomId
          ? typeof newVal === 'function'
            ? { ...room, ...newVal(room) }
            : { ...room, ...newVal }
          : room,
      ),
    );
  };

  const onReceiveMessageListener = useCallback(
    (data: Serialized<Message>) => {
      const message = deserializeMessage(data);
      if (message.room === selectedRoomId)
        updateRoom(message.room!, { lastMessage: message });
      else {
        if (rooms.find((r) => r.id === data.room!) === undefined)
          refetch(); // if the message comes from a room we don't have locally, refetch the rooms from the server
        else
          updateRoom(message.room!, (curr) => ({
            lastMessage: message,
            unreadMessages: curr.unreadMessages + 1,
          }));
      }
    },
    [selectedRoomId],
  );

  const theTheme = useTheme();

  const onBanned = (by: string) => {
    setBannedDialogData({
      by: by,
      roomName: rooms.find((r) => r.id === selectedRoomId)?.name ?? '',
      open: true,
    });
    navigate('/app/chat');
    setSelectedRoomId(null);
    refetch();
  };

  const selectedRoom = rooms.find((room) => room.id === selectedRoomId);

  //Refetch from the server when the conversation displayed changes
  useEffect(() => {
    // setMessages([]); // prevent last loaded conversation from quickly flashing when redirecting to a new conversation as a room is joined or created
    if (selectedRoomId === null) return;
    roomQuery.refetch();
    // mark all messages as read in the rooms list for this room
    updateRoom(selectedRoomId, { unreadMessages: 0 });
  }, [selectedRoomId, roomQuery.refetch]);

  const onRoomEvent = (data: any) => {
    if (data.roomId === selectedRoomId) roomQuery.refetch();
  };

  const onBanEvent = (data: any) => {
    if (data.username !== roomQuery.data?.data.username) onRoomEvent(data);
    else onBanned(data.by);
  };

  const onLeaveEvent = (data: any) => {
    if (data.username !== roomQuery.data?.data.username) onRoomEvent(data);
  };


  useEffect(() => {
    if (!socket.connected) socket.connect();
    socket.on('receive_message', onReceiveMessageListener);
    socket.on('mute', onRoomEvent);
    socket.on('unmute', onRoomEvent);
    socket.on('ban', onBanEvent);
    socket.on('unban', onRoomEvent);
    socket.on('join', onRoomEvent);
    socket.on('leave', onLeaveEvent);
    socket.on('change-role', onRoomEvent);
    return () => {
      socket.off('receive_message', onReceiveMessageListener);
      socket.off('mute', onRoomEvent);
      socket.off('unmute', onRoomEvent);
      socket.off('ban', onBanEvent);
      socket.off('unban', onRoomEvent);
      socket.off('join', onRoomEvent);
      socket.off('leave', onLeaveEvent);
      socket.off('change-role', onRoomEvent);
    };
  }, [socket, selectedRoomId, roomQuery.data?.data]);

  useEffect(() => {
    if (!data) return;
    setRooms(
      data.data.rooms.map((room) => ({
        ...room,
        lastMessage: deserializeMessage(room.lastMessage),
      })),
    );
  }, [data]);

  useEffect(() => {
    if (isLoading) return;
    const roomId = searchParams.get('id');
    if (roomId && rooms.find((r) => r.id === roomId) === undefined) {
      searchParams.delete('id');
      setSearchParams(searchParams);
    } else setSelectedRoomId(roomId ? roomId : null);
  }, [searchParams, rooms]);

  const searchRoom = () => {
    navigate('search');
  };

  const createRoom = () => {
    navigate('create');
  };

  return (
    <div className="container">
      <div
        className="rooms"
        style={{ backgroundColor: theTheme.palette.background.paper }}
      >
        <ListItems
          rooms={rooms.sort(sortRoomFunc).map((room) => ({
            ...room,
            selected: room.id === selectedRoomId,
          }))}
        />
        <Divider />
        <div className="bottom-buttons">
          <Button variant="contained" size="medium" onClick={createRoom}>
            Create room
          </Button>
          <Button variant="contained" size="medium" onClick={searchRoom}>
            Search
          </Button>
        </div>
      </div>

      <chatContext.Provider
        value={{
          rooms,
          updateRoom,
          setRooms,
          roomId: selectedRoomId,
          onBanned: onBanned,
          roomData: roomQuery.data?.data || null,
          refetchRoomData: roomQuery.refetch,
        }}
      >
        <div className="chat-window">
          <div className="chat-header">
            <Stack
              direction="row"
              justifyContent="space-between"
              alignItems={'center'}
              height={'100%'}
            >
              <p>Live Chat</p>
              {selectedRoom?.type !== 'private' && <ContextMenu />}
            </Stack>
          </div>

          <Outlet />
        </div>
      </chatContext.Provider>
      <Dialog
        open={bannedDialogData.open}
        onClose={() => {
          setBannedDialogData((curr) => ({ ...curr, open: false }));
        }}
      >
        <DialogTitle>You have been banned</DialogTitle>
        <DialogContent>
          You have been banned from room{' '}
          <strong>{bannedDialogData?.roomName}</strong> by{' '}
          <strong>{bannedDialogData?.by}</strong>
        </DialogContent>
        <DialogActions>
          <Button
            onClick={() => {
              setBannedDialogData((curr) => ({ ...curr, open: false }));
            }}
            variant="contained"
          >
            OK
          </Button>
        </DialogActions>
      </Dialog>
    </div>
  );
}

export default Layout;
