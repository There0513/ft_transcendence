import React, {
  useEffect,
  useState,
  useRef,
  useCallback,
  useMemo,
} from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import { io, Socket } from 'socket.io-client';
import { useAuth } from '../../tools/auth';
import astroLeft from '../../assets/img/astroTransparent.png';
import astroRight from '../../assets/img/astroTransparent2.png';
import { myApi } from '../../tools/apiHandler';
import { useQuery } from 'react-query';
import { GameGetInfoResponseDTO } from '../../tools/api.autogenerated';
import Alert from '@mui/material/Alert';

const GAME = 1; // tmp for standard version or special version

const socket = io('http://localhost:5000/game', {
  autoConnect: false,
  transports: ['websocket'],
  withCredentials: true,
});

const WALL_OFFSET = 20;

type GameType = 'classic' | 'bonus';

class BallRender {
  private speed: number = 1;
  private readonly size: number;
  public x: number;
  public y: number;
  private gameType: GameType;

  constructor(size: number, x: number, y: number, gameType: GameType) {
    this.size = size;
    this.x = x;
    this.y = y;
    this.gameType = gameType;
  }

  /* standard ball */
  strokeStandardBall(
    context: CanvasRenderingContext2D,
    canvasRef: React.RefObject<HTMLCanvasElement>,
  ) {
    if (!context) return;
    context.fillStyle = '#fff';
    context.beginPath();
    context.arc(
      this.x - 1,
      this.y,
      this.size * canvasRef.current?.width! * 0.015,
      0,
      2 * Math.PI,
      false,
    );
    context.fill();
  }

  /* map starfield - star-ball: */
  strokeStarBall(
    context: CanvasRenderingContext2D,
    r: number,
    n: number,
    inset: number,
  ) {
    if (!context) return;
    context.save();
    context.beginPath();
    context.translate(this.x, this.y);
    context.moveTo(0, 0 - r);
    for (var i = 0; i < n; i++) {
      context.rotate(Math.PI / n);
      context.lineTo(0, 0 - r * inset);
      context.rotate(Math.PI / n);
      context.lineTo(0, 0 - r);
    }
    context.closePath();
    context.fill();
    context.restore();
  }

  /* draw star */ // not needed finally?
  // drawStar(context: CanvasRenderingContext2D) {
  //   var rot = (Math.PI / 2) * 3;
  //   var x = this.x;
  //   var y = this.y;
  //   var step = Math.PI / 5;

  //   context.beginPath();
  //   context.moveTo(this.x, this.y - 25);
  //   for (var i = 0; i < 5; i++) {
  //     x = this.x + Math.cos(rot) * 25;
  //     y = this.y + Math.sin(rot) * 25;
  //     context.lineTo(x, y);
  //     rot += step;

  //     x = this.x + Math.cos(rot) * 10;
  //     y = this.y + Math.sin(rot) * 10;
  //     context.lineTo(x, y);
  //     rot += step;
  //   }
  //   context.lineTo(this.x, this.y - 25);
  //   context.closePath();
  //   context.fillStyle = '#ffe02e';
  //   context.fill();
  // }

  draw(
    context: CanvasRenderingContext2D,
    canvasRef: React.RefObject<HTMLCanvasElement>,
  ) {
    if (this.gameType == 'classic') this.strokeStandardBall(context, canvasRef);
    else this.strokeStarBall(context, 6, 30, 20);
    // this.drawStar(context); // not needed finally?
  }
}

class PaddleRender {
  public readonly id: 1 | 2;
  private readonly height: number;
  private readonly width: number;
  private readonly x: number;
  public y: number;
  private gameType: GameType;

  constructor(
    id: 1 | 2,
    height: number,
    width: number,
    x: number,
    y: number,
    gameType: GameType,
  ) {
    this.id = id;
    this.height = height;
    this.width = width;
    this.x = x;
    this.y = y;
    this.gameType = gameType;
  }

  draw(
    context: CanvasRenderingContext2D,
    canvasRef: React.RefObject<HTMLCanvasElement>,
  ) {
    if (!context) return;
    context.fillStyle = '#fff';
    const y =
      this.y * ((canvasRef.current?.height! - WALL_OFFSET * 2) / 100) +
      WALL_OFFSET;
    const height =
      (canvasRef.current?.height! - WALL_OFFSET * 2) * (this.height / 100);
    const width =
      (canvasRef.current?.height! - WALL_OFFSET * 2) * (this.width / 100);

    const x =
      this.id === 1
        ? WALL_OFFSET
        : canvasRef.current?.width! -
          WALL_OFFSET -
          (canvasRef.current?.height! - WALL_OFFSET * 2) * (this.width / 100);

    /* normal paddle: */

    if (this.gameType == 'classic') context.fillRect(x, y, width, height);
    /* map starfield - astronaut paddle: */ else {
      const astwidth =
        (canvasRef.current?.height! - WALL_OFFSET * 2) * ((638 * 0.064) / 100);
      const astheight =
        (canvasRef.current?.height! - WALL_OFFSET * 2) * ((1550 * 0.064) / 100);
      const newImage = new Image();
      if (this.id === 1) {
        newImage.src = astroLeft;
        context.drawImage(
          newImage,
          x - WALL_OFFSET * 0.5,
          y,
          astwidth * 0.2,
          astheight * 0.2,
        );
      } else {
        newImage.src = astroRight;
        context.drawImage(
          newImage,
          x - WALL_OFFSET,
          y + 1,
          astwidth * 0.2,
          astheight * 0.2,
        );
      }
    }
  }
}

let paddle1 = new PaddleRender(1, 0, 0, 0, 0, 'classic');
let paddle2 = new PaddleRender(2, 0, 0, 0, 0, 'classic');
let ball = new BallRender(1, -100, -100, 'classic');
let score1 = 0;
let score2 = 0;
function getWindowSize() {
  const { innerWidth, innerHeight } = window;
  const verticalWindow = Math.sqrt(
    innerWidth * innerWidth + innerHeight * innerHeight,
  );

  return { innerWidth, innerHeight, verticalWindow };
}

export type GameProps = { watch: boolean };

export default function Game(props: GameProps) {
  const [windowSize, setWindowSize] = useState(getWindowSize());
  const [gameInfo, setGameInfo] = useState<GameGetInfoResponseDTO | null>(null);
  const [playerLeft, setPlayerLeft] = useState(false);
  const [winner, setWinner] = useState('no');
  const [gameType, setGameType] = useState<GameType>('classic');
  const navigate = useNavigate();
  const requestRef = React.useRef<number>();

  const canvasRef = useRef<HTMLCanvasElement>(null);
  const keyPressTimer = useRef<{ timer: number; key: string }>({
    timer: 0,
    key: '',
  });
  const { id } = useParams();
  const { triggerLogin } = useAuth();

  const { isLoading, error, data, refetch } = useQuery(
    'info',
    () => myApi.gameControllerGetInfo(id!, { toastError: true } as any),
    {
      enabled: id !== undefined,
      refetchOnWindowFocus: false,
      refetchOnMount: false,
      refetchOnReconnect: false,
      cacheTime: 0,
    },
  );

  useEffect(() => {
    if (!data) return;
    setGameInfo(data.data);
  }, [data]);

  useEffect(() => {
    if (socket.connected)
      socket.disconnect();
    refetch();
  }, [id]);
  const canvasContext = () => canvasRef.current?.getContext('2d')!;

  const clear = () => {
    const ctx = canvasContext()!;
    if (!ctx) return;
    ctx.fillStyle = 'black';
    ctx!.fillRect(0, 0, canvasRef.current!.width, canvasRef.current!.height);
  };

  /* ********* functions for starfield in special map ********* */

  const makeStars = (count: number) => {
    const out = [];
    for (let i = 0; i < count; i++) {
      const s = {
        x: Math.random() * 1600 - 800,
        y: Math.random() * 900 - 450,
        z: Math.random() * 3000,
      };
      out.push(s);
    }
    return out;
  };

  let stars = makeStars(6000);
  let prevTime: any = 1;

  /* drawing a single star | Weâ€™ll color exactly 1/1.5 pixel with a brightness between 0 and 1.
    The higher the value, the brighter the pixel. */
  const putPixel = (x: number, y: number, brightness: number) => {
    const ctx = canvasContext();
    if (!ctx) return;
    const intensity = brightness * 255;
    const rgb = 'rgb(' + intensity + ',' + intensity + ',' + intensity + ')';
    ctx.fillStyle = rgb;
    ctx.fillRect(x, y, 1.5, 1.5);
  };

  const moveStars = (distance: number) => {
    if (distance === undefined) return;
    const count = stars.length;
    for (var i = 0; i < count; i++) {
      const s = stars[i];
      s.z -= distance;
      while (s.z <= 1) {
        s.z += 1000;
      }
    }
  };

  const tick = (time: number) => {
    let elapsed = time - prevTime;
    prevTime = time;
    moveStars(elapsed * 0.1);
    clear();

    if (!canvasRef.current) return;
    const cx = canvasRef.current!.width / 2;
    const cy = canvasRef.current!.height / 2;
    const count = stars.length;
    for (var i = 0; i < count; i++) {
      const star = stars[i];
      const x = cx + star.x / (star.z * 0.001);
      const y = cy + star.y / (star.z * 0.001);

      if (
        x < 0 ||
        x >= canvasRef.current!.width ||
        y < 0 ||
        y >= canvasRef.current!.height
      ) {
        continue;
      }
      const d = star.z / 750.0;
      const b = 1 - d * d;
      putPixel(x, y, b);
    }
  };

  /* ********* functions for starfield in special map ********* */

  // draw canvas each time to overwrite old paddles + ball positions
  const drawBoard = (
    time: number,
    context: CanvasRenderingContext2D,
    score1: number,
    score2: number,
  ) => {
    /* background black -> normal map */
    const ctx = canvasContext();
    if (!ctx) return;
    if (gameType === 'classic') clear();
    else {
      tick(time);
    }

    //draw court outline
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 5;
    ctx.strokeRect(
      10,
      10,
      canvasRef.current!.width - 20,
      canvasRef.current!.height - 20,
    );

    //draw center lines
    for (var i = 0; i + 30 < canvasRef.current!.height; i += 30) {
      ctx!.fillStyle = '#fff';
      ctx!.fillRect(
        canvasRef.current!.width / 2 - 10,
        i + 10,
        canvasRef.current!.width * 0.03,
        20,
      );
    }

    //draw scores
    ctx!.font = `${canvasRef.current?.width! * 0.05}px verdana`;
    ctx!.fillText(
      score2.toString(),
      ((getWindowSize().verticalWindow * 0.47) / 2) * 0.6,
      (getWindowSize().verticalWindow / 4) * 0.15,
      1000,
    );
    ctx!.fillText(
      score1.toString(),
      ((getWindowSize().verticalWindow * 0.47) / 2) * 1.15,
      (getWindowSize().verticalWindow / 4) * 0.15,
    );
    if (gameInfo?.player1.user.username) {
      ctx!.font = `${canvasRef.current?.width! * 0.03}px verdana`;
      ctx!.fillText(
        gameInfo?.player1.user.username!.toString(),
        ((getWindowSize().verticalWindow * 0.47) / 2) * 0.1,
        (getWindowSize().verticalWindow / 4) * 0.15,
        1000,
      );
    }
    if (gameInfo?.player2.user.username) {
      ctx!.fillText(
        gameInfo?.player2.user.username!.toString(),
        ((getWindowSize().verticalWindow * 0.47) / 2) * 1.6,
        (getWindowSize().verticalWindow / 4) * 0.15,
        1000,
      );
    }
  };

  const drawGameBoard = (time: number, score1: number, score2: number) => {
    canvasContext()!.font = '30px Orbitron';
    drawBoard(time, canvasContext()!, score1, score2);
  };

  const drawEntities = (
    paddle1: PaddleRender,
    paddle2: PaddleRender,
    ball?: BallRender,
  ) => {
    ball?.draw(canvasContext()!, canvasRef);
    paddle1.draw(canvasContext()!, canvasRef);
    paddle2.draw(canvasContext()!, canvasRef);
  };

  const onKeyDown = useCallback(function (this: Window, e: KeyboardEvent) {
    const inputKeys = ['w', 's', 'ArrowUp', 'ArrowDown'];
    if (e.repeat) return;
    if (!inputKeys.includes(e.key)) return;
    keyPressTimer.current.key = e.key;
    this.clearInterval(keyPressTimer.current.timer);
    keyPressTimer.current.timer = this.setInterval(() => {
      socket.emit('KEY_PRESSED', {
        key: e.key === 's' || e.key === 'ArrowDown' ? 'DOWN' : 'UP',
      });
    }, 30);
  }, []);

  const onKeyUp = useCallback(function (this: Window, e: KeyboardEvent) {
    const inputKeys = ['w', 's', 'ArrowUp', 'ArrowDown'];
    if (e.repeat) return;
    if (!inputKeys.includes(e.key)) return;
    if (keyPressTimer.current.key !== e.key) return;
    this.clearInterval(keyPressTimer.current.timer);
  }, []);

  const onBallPosition = useCallback((data: any) => {
    ball.x =
      data.x * ((canvasRef.current?.width! - WALL_OFFSET * 2) / 100) +
      WALL_OFFSET;
    ball.y =
      data.y * ((canvasRef.current?.height! - WALL_OFFSET * 2) / 100) +
      WALL_OFFSET;
    score1 = data.score2;
    score2 = data.score1;
  }, []);

  const onSetup = useCallback(
    (data: any) => {
      setGameType(data.gameType);
      // drawGameBoard(score1, score2);

      paddle1 = new PaddleRender(
        1,
        data.paddle1.height,
        data.paddle1.width,
        data.paddle1.pos.x,
        data.paddle2.pos.y,
        data.gameType,
      );
      paddle2 = new PaddleRender(
        2,
        data.paddle2.height,
        data.paddle2.width,
        data.paddle2.pos.x,
        data.paddle2.pos.y,
        data.gameType,
      );
      ball = new BallRender(1, data.ball.pos.x, data.ball.pos.y, data.gameType);

      drawEntities(paddle1, paddle2);
    },
    [canvasContext],
  );

  // const onNotPlayer = ({ id }: { id: string }) => {
  const onFinish = ({ end }: { end: string }) => {
    navigate(`/app/game/end/${end}`);
  };

  const gameLoop = useCallback(
    (time: number) => {
      if (score2 === 10) {
        setWinner(gameInfo?.player1.user.username!);
        score1 = 0;
        score2 = 0;
        socket.emit('GameEnds', {
          end: gameInfo?.player1.user.username!,
        });
        return;
      }
      if (score1 === 10) {
        setWinner(gameInfo?.player2.user.username!);
        score1 = 0;
        score2 = 0;
        socket.emit('GameEnds', {
          end: gameInfo?.player2.user.username!,
        });
        return;
      }
      drawBoard(time, canvasContext()!, score1, score2);
      ball.draw(canvasContext()!, canvasRef);
      paddle1?.draw(canvasContext()!, canvasRef);
      paddle2?.draw(canvasContext()!, canvasRef);
      requestRef.current = requestAnimationFrame(gameLoop);
    },
    [paddle1, paddle2, ball, canvasContext, canvasRef],
  );

  function handleWindowResize() {
    setWindowSize(getWindowSize());
    drawEntities(paddle1, paddle2);
  }

  // useEffect for responsivity
  useEffect(() => {
    window.addEventListener('resize', handleWindowResize);
    return () => {
      window.removeEventListener('resize', handleWindowResize);
    };
  }, [canvasRef, canvasContext]);

  useEffect(() => {
    if (!socket.connected) {
      setWinner('no');
      setPlayerLeft(false);
      socket.connect();
    }
    return () => {
      cancelAnimationFrame(requestRef.current!);
      socket.disconnect();
    };
  }, []);
  const delay = (ms: number | undefined) =>
    new Promise((res) => setTimeout(res, ms));

  const onConnect = useCallback(() => {
    setWinner('no');
    setPlayerLeft(false);
    if (props.watch) socket.emit('WATCH', { id });
    else socket.emit('CONNECTED', { id });
  }, [id]);

  const onConnectionError = useCallback((err: Error) => {
    if (err.message === 'Invalid or missing token') triggerLogin();
    else console.error(err);
  }, []);

  const onPlayerLeft = () => {
    if (winner !== 'no' && winner !== 'left') return;
    setPlayerLeft(true);
    navigate(`/app/game/end/left`);
  };

  const onNotPlayer = ({ id }: { id: string }) => {
    navigate(`/app/watch/${id}`);
  };

  useEffect(() => {
    if (!canvasContext || !canvasRef.current) return;
    if (!props.watch) {
      window.addEventListener('keydown', onKeyDown);
      window.addEventListener('keyup', onKeyUp);
    }
    score1 = 0;
    score2 = 0;

    if (!socket.connected)
      socket.connect();

    socket.on('playerLeft', onPlayerLeft);
    socket.on('connect', onConnect);
    socket.on('SETUP', onSetup);
    socket.on('PADDLE_MOVEMENT', onPaddleMovement);
    socket.on('BALL_POSITION', onBallPosition);
    socket.on('NOT_PLAYER', onNotPlayer);
    socket.on('exception', (data) => console.log('exception', data));
    socket.on('connect_error', onConnectionError);
    socket.on('Ends', onFinish);
    gameLoop(0);
    // requestAnimationFrame(gameLoop);
    return () => {
      window.removeEventListener('keydown', onKeyDown);
      window.removeEventListener('keyup', onKeyUp);
      socket.off('SETUP');
      socket.off('PADDLE_MOVEMENT');
      socket.off('BALL_POSITION');
      socket.off('NOT_PLAYER', onNotPlayer);
      socket.off('connect');
      socket.off('exception');
      socket.off('connect_error');
      cancelAnimationFrame(requestRef.current!);
    };
  }, [canvasContext, id, canvasRef, gameInfo]);

  const onPaddleMovement = useCallback(
    (data: { paddle: 1 | 2; y: number }) => {
      if (data.paddle === 1) paddle1.y = data.y;
      else paddle2.y = data.y;
    },
    [canvasRef, canvasContext],
  );
  const verticalWindow = Math.sqrt(
    windowSize.innerWidth * windowSize.innerWidth +
      windowSize.innerHeight * windowSize.innerHeight,
  );

  return (
    <div style={{ display: 'flex', flexDirection: 'column' }}>
      <canvas
        width={verticalWindow * 0.3 * 2 - verticalWindow * 0.3 * 0.5}
        height={verticalWindow * 0.3}
        id="game-canvas"
        ref={canvasRef}
      ></canvas>
    </div>
  );
}
